var documenterSearchIndex = {"docs":
[{"location":"literate_example/#Distributed-Calibration-Tutorial-Using-Julia-Workers","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial Using Julia Workers","text":"","category":"section"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"This example will teach you how to use ClimaCalibrate to parallelize your calibration with workers. Workers are additional processes spun up to run code in a distributed fashion. In this tutorial, we will run ensemble members' forward models on different workers.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"The example calibration uses CliMA's atmosphere model, ClimaAtmos.jl, in a column spatial configuration for 30 days to simulate outgoing radiative fluxes. Radiative fluxes are used in the observation map to calibrate the astronomical unit.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"First, we load in some necessary packages.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"using Distributed\nimport ClimaCalibrate as CAL\nimport ClimaAnalysis: SimDir, get, slice, average_xy\nusing ClimaUtilities.ClimaArtifacts\nimport EnsembleKalmanProcesses: I, ParameterDistributions.constrained_gaussian","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"Next, we add workers. These are primarily added by Distributed.addprocs or by starting Julia with multiple processes: julia -p <nprocs>.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"addprocs itself initializes the workers and registers them with the main Julia process, but there are multiple ways to call it. The simplest is just addprocs(nprocs), which will create new local processes on your machine. The other is to use SlurmManager, which will acquire and start workers on Slurm resources. You can use keyword arguments to specify the Slurm resources:","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"addprocs(ClimaCalibrate.SlurmManager(nprocs), gpus_per_task = 1, time = \"01:00:00\")","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"For this example, we would add one worker if it was compatible with Documenter.jl:","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"addprocs(1)","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"We can see the number of workers and their ID numbers:","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"nworkers()","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"workers()","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"We can call functions on the worker using remotecall. We pass in the function name and the worker ID followed by the function arguments.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"remotecall_fetch(*, 1, 4, 4)","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"ClimaCalibrate uses this functionality to run the forward model on workers.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"Since the workers start in their own Julia sessions, we need to import packages and declare variables. Distributed.@everywhere executes code on all workers, allowing us to load the code that they need.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"@everywhere begin\n    output_dir = joinpath(\"output\", \"climaatmos_calibration\")\n    import ClimaCalibrate as CAL\n    import ClimaAtmos as CA\n    import ClimaComms\nend\noutput_dir = joinpath(\"output\", \"climaatmos_calibration\")\nmkpath(output_dir)","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"First, we need to set up the forward model, which take in the sampled parameters, runs, and saves diagnostic output that can be processed and compared to observations. The forward model must override ClimaCalibrate.forward_model(iteration, member), since the workers will run this function in parallel.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"Since forward_model(iteration, member) only takes in the iteration and member numbers, so we need to use these as hooks to set the model parameters and output directory. Two useful functions:","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"path_to_ensemble_member: Returns the ensemble member's output directory\nparameter_path: Returns the ensemble member's parameter file as specified by EKP.TOMLInterface","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"The forward model below is running ClimaAtmos.jl in a minimal column spatial configuration.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"@everywhere function CAL.forward_model(iteration, member)\n    config_dict = Dict(\n        \"dt\" => \"2000secs\",\n        \"t_end\" => \"30days\",\n        \"config\" => \"column\",\n        \"h_elem\" => 1,\n        \"insolation\" => \"timevarying\",\n        \"output_dir\" => output_dir,\n        \"output_default_diagnostics\" => false,\n        \"dt_rad\" => \"6hours\",\n        \"rad\" => \"clearsky\",\n        \"co2_model\" => \"fixed\",\n        \"log_progress\" => false,\n        \"diagnostics\" => [\n            Dict(\n                \"reduction_time\" => \"average\",\n                \"short_name\" => \"rsut\",\n                \"period\" => \"30days\",\n                \"writer\" => \"nc\",\n            ),\n        ],\n    )\n    #md # Set the output path for the current member\n    member_path = CAL.path_to_ensemble_member(output_dir, iteration, member)\n    config_dict[\"output_dir\"] = member_path\n\n    #md # Set the parameters for the current member\n    parameter_path = CAL.parameter_path(output_dir, iteration, member)\n    if haskey(config_dict, \"toml\")\n        push!(config_dict[\"toml\"], parameter_path)\n    else\n        config_dict[\"toml\"] = [parameter_path]\n    end\n\n    #md # Turn off default diagnostics\n    config_dict[\"output_default_diagnostics\"] = false\n\n    comms_ctx = ClimaComms.SingletonCommsContext()\n    atmos_config = CA.AtmosConfig(config_dict; comms_ctx)\n    simulation = CA.get_simulation(atmos_config)\n    CA.solve_atmos!(simulation)\n    return simulation\nend","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"Next, the observation map is required to process a full ensemble of model output for the ensemble update step. The observation map just takes in the iteration number, and always outputs an array. For observation map output G_ensemble, G_ensemble[:, m] must the output of ensemble member m. This is needed for compatibility with EnsembleKalmanProcesses.jl.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"const days = 86_400\nfunction CAL.observation_map(iteration)\n    single_member_dims = (1,)\n    G_ensemble = Array{Float64}(undef, single_member_dims..., ensemble_size)\n\n    for m in 1:ensemble_size\n        member_path = CAL.path_to_ensemble_member(output_dir, iteration, m)\n        simdir_path = joinpath(member_path, \"output_active\")\n        if isdir(simdir_path)\n            simdir = SimDir(simdir_path)\n            G_ensemble[:, m] .= process_member_data(simdir)\n        else\n            G_ensemble[:, m] .= NaN\n        end\n    end\n    return G_ensemble\nend","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"Separating out the individual ensemble member output processing often results in more readable code.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"function process_member_data(simdir::SimDir)\n    isempty(simdir.vars) && return NaN\n    rsut =\n        get(simdir; short_name = \"rsut\", reduction = \"average\", period = \"30d\")\n    return slice(average_xy(rsut); time = 30days).data\nend","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"Now, we can set up the remaining experiment details:","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"ensemble size, number of iterations\nthe prior distribution\nthe observational data","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"ensemble_size = 30\nn_iterations = 7\nnoise = 0.1 * I\nprior = constrained_gaussian(\"astronomical_unit\", 6e10, 1e11, 2e5, Inf)","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"For a perfect model, we generate observations from the forward model itself. This is most easily done by creating an empty parameter file and running the 0th ensemble member:","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"@info \"Generating observations\"\nparameter_file = CAL.parameter_path(output_dir, 0, 0)\nmkpath(dirname(parameter_file))\ntouch(parameter_file)\nsimulation = CAL.forward_model(0, 0)","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"Lastly, we use the observation map itself to generate the observations.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"observations = Vector{Float64}(undef, 1)\nobservations .= process_member_data(SimDir(simulation.output_dir))","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"Now we are ready to run our calibration, putting it all together using the calibrate function. The WorkerBackend will automatically use all workers available to the main Julia process. Other backends are available for forward models that can't use workers or need to be parallelized internally. The simplest backend is the JuliaBackend, which runs all ensemble members sequentially and does not require Distributed.jl. For more information, see the Backends page.","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"eki = CAL.calibrate(\n    CAL.WorkerBackend,\n    ensemble_size,\n    n_iterations,\n    observations,\n    noise,\n    prior,\n    output_dir,\n)","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"","category":"page"},{"location":"literate_example/","page":"Distributed Calibration Tutorial","title":"Distributed Calibration Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Model-Interface","page":"API","title":"Model Interface","text":"","category":"section"},{"location":"api/#ClimaCalibrate.forward_model","page":"API","title":"ClimaCalibrate.forward_model","text":"forward_model(iteration, member)\n\nExecute the forward model simulation with the given configuration.\n\nThis function must be overridden by a component's model interface and  should set things like the parameter path and other member-specific settings.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.observation_map","page":"API","title":"ClimaCalibrate.observation_map","text":"observation_map(iteration)\n\nRuns the observation map for the specified iteration. This function must be implemented for each calibration experiment.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.analyze_iteration","page":"API","title":"ClimaCalibrate.analyze_iteration","text":"analyze_iteration(ekp, g_ensemble, prior, output_dir, iteration)\n\nAfter each evaluation of the observation map and before updating the ensemble, analyze_iteration is evaluated.\n\nThis function is optional to implement.\n\nFor example, one may want to print information from the eki object or plot g_ensemble.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.postprocess_g_ensemble","page":"API","title":"ClimaCalibrate.postprocess_g_ensemble","text":"postprocess_g_ensemble(ekp, g_ensemble, prior, output_dir, iteration)\n\nPostprocess g_ensemble after evaluating the observation map and before updating the ensemble.\n\n\n\n\n\n","category":"function"},{"location":"api/#Worker-Interface","page":"API","title":"Worker Interface","text":"","category":"section"},{"location":"api/#ClimaCalibrate.add_workers","page":"API","title":"ClimaCalibrate.add_workers","text":"add_workers(\n    nworkers;\n    device = :gpu,\n    cluster = :auto,\n    time = DEFAULT_WALLTIME,\n    kwargs...\n)\n\nAdd nworkers worker processes to the current Julia session, automatically detecting and configuring for the available computing environment.\n\nArguments\n\nnworkers::Int: The number of worker processes to add.\ndevice::Symbol = :gpu: The target compute device type, either :gpu (1 GPU, 4 CPU cores) or :cpu (1 CPU core).\ncluster::Symbol = :auto: The cluster management system to use. Options:\n:auto: Auto-detect available cluster environment (SLURM, PBS, or local)\n:slurm: Force use of SLURM scheduler\n:pbs: Force use of PBS scheduler\n:local: Force use of local processing (standard addprocs)\ntime::Int = DEFAULT_WALLTIME: Walltime in minutes, will be formatted appropriately for the cluster system\nkwargs: Other kwargs can be passed directly through to addprocs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.WorkerBackend","page":"API","title":"ClimaCalibrate.WorkerBackend","text":"WorkerBackend\n\nUsed to run calibrations on Distributed.jl's workers. For use on a Slurm cluster, see SlurmManager.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCalibrate.SlurmManager","page":"API","title":"ClimaCalibrate.SlurmManager","text":"SlurmManager(ntasks=get(ENV, \"SLURM_NTASKS\", 1))\n\nThe ClusterManager for Slurm clusters, taking in the number of tasks to request with srun.\n\nTo execute the srun command, run addprocs(SlurmManager(ntasks))\n\nKeyword arguments can be passed to srun: addprocs(SlurmManager(ntasks), gpus_per_task=1)\n\nBy default the workers will inherit the running Julia environment.\n\nTo run a calibration, call calibrate(WorkerBackend, ...)\n\nTo run functions on a worker, call remotecall(func, worker_id, args...)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCalibrate.PBSManager","page":"API","title":"ClimaCalibrate.PBSManager","text":"PBSManager(ntasks)\n\nThe ClusterManager for PBS/Torque clusters, taking in the number of tasks to request with qsub.\n\nTo execute the qsub command, run addprocs(PBSManager(ntasks)).  Unlike the SlurmManager, this will not nest scheduled jobs, but will acquire new resources.\n\nKeyword arguments can be passed to qsub: addprocs(PBSManager(ntasks), nodes=2)\n\nBy default, the workers will inherit the running Julia environment.\n\nTo run a calibration, call calibrate(WorkerBackend, ...)\n\nTo run functions on a worker, call remotecall(func, worker_id, args...)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCalibrate.set_worker_loggers","page":"API","title":"ClimaCalibrate.set_worker_loggers","text":"set_worker_loggers(workers = workers())\n\nSet the global logger to a simple file logger for the given workers.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.map_remotecall_fetch","page":"API","title":"ClimaCalibrate.map_remotecall_fetch","text":"map_remotecall_fetch(f::Function, args...; workers = workers())\n\nCall function f from each worker and wait for the results to return.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.foreach_remotecall_wait","page":"API","title":"ClimaCalibrate.foreach_remotecall_wait","text":"foreach_remotecall_wait(f::Function, args...; workers = workers())\n\nCall function f from each worker.\n\n\n\n\n\n","category":"function"},{"location":"api/#Backend-Interface","page":"API","title":"Backend Interface","text":"","category":"section"},{"location":"api/#ClimaCalibrate.calibrate","page":"API","title":"ClimaCalibrate.calibrate","text":"calibrate(backend, ekp::EnsembleKalmanProcess, ensemble_size, n_iterations, prior, output_dir)\ncalibrate(backend, ensemble_size, n_iterations, observations, noise, prior, output_dir; ekp_kwargs...)\n\nRun a full calibration on the given backend.\n\nIf the EKP struct is not given, it will be constructed upon initialization.  While EKP keyword arguments are passed through to the EKP constructor, if using many keywords it is recommended to construct the EKP object and pass it into calibrate.\n\nAvailable Backends: WorkerBackend, CaltechHPCBackend, ClimaGPUBackend, DerechoBackend, JuliaBackend\n\nDerecho, ClimaGPU, and CaltechHPC backends are designed to run on a specific high-performance computing cluster. WorkerBackend uses Distributed.jl to run the forward model on workers.\n\nKeyword Arguments for HPC backends\n\n`model_interface: Path to the model interface file.\nhpc_kwargs: Dictionary of resource arguments for HPC clusters, passed to the job scheduler.\nverbose::Bool: Enable verbose logging.\nAny keyword arguments for the EnsembleKalmanProcess constructor, such as scheduler\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.JuliaBackend","page":"API","title":"ClimaCalibrate.JuliaBackend","text":"JuliaBackend\n\nThe simplest backend, used to run a calibration in Julia without any parallelization.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCalibrate.DerechoBackend","page":"API","title":"ClimaCalibrate.DerechoBackend","text":"DerechoBackend\n\nUsed for NSF NCAR's Derecho supercomputing system.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCalibrate.CaltechHPCBackend","page":"API","title":"ClimaCalibrate.CaltechHPCBackend","text":"CaltechHPCBackend\n\nUsed for Caltech's high-performance computing cluster.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCalibrate.ClimaGPUBackend","page":"API","title":"ClimaCalibrate.ClimaGPUBackend","text":"ClimaGPUBackend\n\nUsed for CliMA's private GPU server.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCalibrate.get_backend","page":"API","title":"ClimaCalibrate.get_backend","text":"get_backend()\n\nGet ideal backend for deploying forward model runs.  Each backend is found via gethostname(). Defaults to JuliaBackend if none is found.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.model_run","page":"API","title":"ClimaCalibrate.model_run","text":"model_run(backend, iter, member, output_dir, experiment_dir; model_interface, verbose, hpc_kwargs)\n\nConstruct and execute a command to run a single forward model on a given job scheduler.\n\nUses the given backend to run slurm_model_run or pbs_model_run.\n\nArguments:\n\niter: Iteration number\nmember: Member number\noutput_dir: Calibration experiment output directory\nproject_dir: Directory containing the experiment's Project.toml\nmodel_interface: Model interface file\nmoduleloadstr: Commands which load the necessary modules\nhpc_kwargs: Dictionary containing the resources for the job. Easily generated using kwargs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.module_load_string","page":"API","title":"ClimaCalibrate.module_load_string","text":"module_load_string(backend)\n\nReturn a string that loads the correct modules for a given backend when executed via bash.\n\n\n\n\n\n","category":"function"},{"location":"api/#Job-Scheduler","page":"API","title":"Job Scheduler","text":"","category":"section"},{"location":"api/#ClimaCalibrate.wait_for_jobs","page":"API","title":"ClimaCalibrate.wait_for_jobs","text":"wait_for_jobs(jobids, output_dir, iter, experiment_dir, model_interface, module_load_str, model_run_func; verbose, hpc_kwargs, reruns=1)\n\nWait for a set of jobs to complete. If a job fails, it will be rerun up to reruns times.\n\nThis function monitors the status of multiple jobs and handles failures by rerunning the failed jobs up to the specified number of reruns. It logs errors and job completion status, ensuring all jobs are completed before proceeding.\n\nArguments:\n\njobids: Vector of job IDs.\noutput_dir: Directory for output.\niter: Iteration number.\nexperiment_dir: Directory for the experiment.\nmodel_interface: Interface to the model.\nmodule_load_str: Commands to load necessary modules.\nmodel_run_func: Function to run the model.\nverbose: Print detailed logs if true.\nhpc_kwargs: HPC job parameters.\nreruns: Number of times to rerun failed jobs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.log_member_error","page":"API","title":"ClimaCalibrate.log_member_error","text":"log_member_error(output_dir, iteration, member, verbose=false)\n\nLog a warning message when an error occurs. If verbose, includes the ensemble member's output.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.kill_job","page":"API","title":"ClimaCalibrate.kill_job","text":"kill_job(jobid::SlurmJobID)\nkill_job(jobid::PBSJobID)\n\nEnd a running job, catching errors in case the job can not be ended.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.job_status","page":"API","title":"ClimaCalibrate.job_status","text":"job_status(job_id)\n\nParse the slurm job_id's state and return one of three status symbols: :PENDING, :RUNNING, or :COMPLETED.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.kwargs","page":"API","title":"ClimaCalibrate.kwargs","text":"kwargs(; kwargs...)\n\nCreate a dictionary from keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.slurm_model_run","page":"API","title":"ClimaCalibrate.slurm_model_run","text":"slurm_model_run(iter, member, output_dir, experiment_dir, model_interface, module_load_str; hpc_kwargs)\n\nConstruct and execute a command to run a single forward model on Slurm. Helper function for model_run.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.generate_sbatch_script","page":"API","title":"ClimaCalibrate.generate_sbatch_script","text":"generate_sbatch_script(iter, member, output_dir, experiment_dir, model_interface; module_load_str, hpc_kwargs, exeflags=\"\")\n\nGenerate a string containing an sbatch script to run the forward model. hpc_kwargs is turned into a series of sbatch directives using generate_sbatch_directives. module_load_str is used to load the necessary modules and can be obtained via module_load_string. exeflags is a string of flags to pass to the Julia executable (defaults to empty string).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.generate_sbatch_directives","page":"API","title":"ClimaCalibrate.generate_sbatch_directives","text":"generate_sbatch_directives(hpc_kwargs)\n\nGenerate Slurm sbatch directives from HPC kwargs. \n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.submit_slurm_job","page":"API","title":"ClimaCalibrate.submit_slurm_job","text":"submit_slurm_job(sbatch_filepath; env=deepcopy(ENV))\n\nSubmit a job to the Slurm scheduler using sbatch, removing unwanted environment variables.\n\nUnset variables: \"SLURMMEMPERCPU\", \"SLURMMEMPERGPU\", \"SLURMMEMPER_NODE\"\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.pbs_model_run","page":"API","title":"ClimaCalibrate.pbs_model_run","text":"pbs_model_run(iter, member, output_dir, experiment_dir, model_interface, module_load_str; hpc_kwargs)\n\nConstruct and execute a command to run a single forward model on PBS Pro. Helper function for model_run.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.generate_pbs_script","page":"API","title":"ClimaCalibrate.generate_pbs_script","text":"generatepbsscript(         iter, member,         outputdir, experimentdir, modelinterface;         moduleloadstr, hpckwargs,     )\n\nGenerate a string containing a PBS script to run the forward model.\n\nReturns:\n\nqsub_contents::Function: A function generating the content of the PBS script based on the provided arguments.    This will run the contents of the julia_script, which have to be run from a file due to Derecho's set_gpu_rank.\njulia_script::String: The Julia script string to be executed by the PBS job. \n\nHelper function for pbs_model_run.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.submit_pbs_job","page":"API","title":"ClimaCalibrate.submit_pbs_job","text":"submit_pbs_job(sbatch_filepath; env=deepcopy(ENV))\n\nSubmit a job to the PBS Pro scheduler using qsub, removing unwanted environment variables.\n\nUnset variables: \"PBSMEMPERCPU\", \"PBSMEMPERGPU\", \"PBSMEMPER_NODE\"\n\n\n\n\n\n","category":"function"},{"location":"api/#EnsembleKalmanProcesses-Interface","page":"API","title":"EnsembleKalmanProcesses Interface","text":"","category":"section"},{"location":"api/#ClimaCalibrate.initialize","page":"API","title":"ClimaCalibrate.initialize","text":"initialize(eki::EKP.EnsembleKalmanProcess, prior, output_dir)\ninitialize(ensemble_size, observations, noise, prior, output_dir)\n\nInitialize a calibration, saving the initial parameter ensemble to a folder within output_dir.\n\nIf no EKP struct is given, construct an EKP struct and return it.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.save_G_ensemble","page":"API","title":"ClimaCalibrate.save_G_ensemble","text":"save_G_ensemble(output_dir::AbstractString, iteration, G_ensemble)\n\nSaves the ensemble's observation map output to the correct directory based on the provided configuration. Takes an output directory, iteration number, and the ensemble output to save.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.update_ensemble","page":"API","title":"ClimaCalibrate.update_ensemble","text":"update_ensemble(output_dir::AbstractString, iteration, prior)\n\nUpdates the EnsembleKalmanProcess object and saves the parameters for the next iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.update_ensemble!","page":"API","title":"ClimaCalibrate.update_ensemble!","text":"update_ensemble!(ekp, G_ens, output_dir, iteration, prior)\n\nUpdates an EKP object with data G_ens, saving the object and final parameters to disk.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.observation_map_and_update!","page":"API","title":"ClimaCalibrate.observation_map_and_update!","text":"observation_map_and_update!(ekp, output_dir, iteration, prior)\n\nCompute the observation map and update the given EKP object.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.get_prior","page":"API","title":"ClimaCalibrate.get_prior","text":"get_prior(param_dict::AbstractDict; names = nothing)\nget_prior(prior_path::AbstractString; names = nothing)\n\nConstructs the combined prior distribution from a param_dict or a TOML configuration file specified by prior_path. If names is provided, only those parameters are used.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.get_param_dict","page":"API","title":"ClimaCalibrate.get_param_dict","text":"get_param_dict(distribution; names)\n\nGenerates a dictionary for parameters based on the specified distribution, assumed to be of floating-point type. If names is not provided, the distribution's names will be used.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.path_to_iteration","page":"API","title":"ClimaCalibrate.path_to_iteration","text":"path_to_iteration(output_dir, iteration)\n\nReturn the path to the directory for a given iteration within the specified output directory.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.path_to_ensemble_member","page":"API","title":"ClimaCalibrate.path_to_ensemble_member","text":"path_to_ensemble_member(output_dir, iteration, member)\n\nReturn the path to an ensemble member's directory for a given iteration and member number.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.path_to_model_log","page":"API","title":"ClimaCalibrate.path_to_model_log","text":"path_to_model_log(output_dir, iteration, member)\n\nReturn the path to an ensemble member's forward model log for a given iteration and member number.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.parameter_path","page":"API","title":"ClimaCalibrate.parameter_path","text":"parameter_path(output_dir, iteration, member)\n\nReturn the path to an ensemble member's parameter file.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.minibatcher_over_samples","page":"API","title":"ClimaCalibrate.minibatcher_over_samples","text":"minibatcher_over_samples(n_samples, batch_size)\n\nCreate a FixedMinibatcher that divides n_samples into batches of size batch_size.\n\nIf n_samples is not divisible by batch_size, the remaining samples will be dropped.\n\n\n\n\n\nminibatcher_over_samples(samples, batch_size)\n\nCreate a FixedMinibatcher that divides a vector of samples into batches of size batch_size.\n\nIf the number of samples is not divisible by batch_size, the remaining samples will be dropped.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCalibrate.observation_series_from_samples","page":"API","title":"ClimaCalibrate.observation_series_from_samples","text":"observation_series_from_samples(samples, batch_size, names = nothing)\n\nCreate an EKP.ObservationSeries from a vector of EKP.Observation samples.\n\nIf the number of samples is not divisible by batch_size, the remaining samples will be dropped.\n\n\n\n\n\n","category":"function"},{"location":"emulate_sample/#Emulate-and-Sample","page":"Emulate and Sample","title":"Emulate and Sample","text":"","category":"section"},{"location":"emulate_sample/","page":"Emulate and Sample","title":"Emulate and Sample","text":"Once you have run a successful calibration, we can fit an emulator to the resulting input/output pairs.","category":"page"},{"location":"emulate_sample/","page":"Emulate and Sample","title":"Emulate and Sample","text":"First, import the necessary packages:","category":"page"},{"location":"emulate_sample/","page":"Emulate and Sample","title":"Emulate and Sample","text":"import JLD2\n\nusing CalibrateEmulateSample.Emulators\nusing CalibrateEmulateSample.MarkovChainMonteCarlo\n\nimport EnsembleKalmanProcesses as EKP\nusing EnsembleKalmanProcesses.ParameterDistributions\nusing EnsembleKalmanProcesses.TOMLInterface\n\nimport ClimaCalibrate as CAL","category":"page"},{"location":"emulate_sample/","page":"Emulate and Sample","title":"Emulate and Sample","text":"Next, load in the data, EKP object, and prior distribution. These values are taken from the Held-Suarez perfect model experiment in ClimaAtmos.","category":"page"},{"location":"emulate_sample/","page":"Emulate and Sample","title":"Emulate and Sample","text":"asset_path = joinpath(\n    pkgdir(CAL),\n    \"docs\",\n    \"src\",\n    \"assets\")\n\nekp = JLD2.load_object(joinpath(asset_path, \"emulate_example_ekiobj.jld2\"))\ny_obs = ekp.obs_mean\ny_noise_cov = ekp.obs_noise_cov\ninitial_params = [EKP.get_u_final(ekp)[1]]\n\nprior_path = joinpath(asset_path, \"emulate_example_prior.toml\")\nprior = CAL.get_prior(prior_path)","category":"page"},{"location":"emulate_sample/","page":"Emulate and Sample","title":"Emulate and Sample","text":"Get the input-output pairs which will be used to train the emulator.  The inputs are the parameter values, and the outputs are the result of the observation map.  In thise case, the outputs are the average air temperature at roughly 500 meters.","category":"page"},{"location":"emulate_sample/","page":"Emulate and Sample","title":"Emulate and Sample","text":"input_output_pairs = CAL.get_input_output_pairs(ekp)","category":"page"},{"location":"emulate_sample/","page":"Emulate and Sample","title":"Emulate and Sample","text":"Next, create the Gaussian Process-based emulator and Markov chain.  The samples from the chain can be used in future predictive model runs with the same configuration. The posterior distribution can be saved to a JLD2 file using save_posterior. Samples can be extracted from the posterior using ClimaParams.","category":"page"},{"location":"emulate_sample/","page":"Emulate and Sample","title":"Emulate and Sample","text":"emulator = CAL.gp_emulator(input_output_pairs, y_noise_cov)\n(; mcmc, chain) = CAL.sample(emulator, y_obs, prior, initial_params)\nconstrained_posterior = CAL.save_posterior(mcmc, chain; filename = \"samples.jld2\")\ndisplay(chain)","category":"page"},{"location":"quickstart/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Every calibration requires","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"a forward model, which uses input parameters to return diagnostic output\nobservational data, which can be a Vector or an EnsembleKalmanProcess.Observation\na prior parameter distribution. The easiest way to construct a distribution is with the EnsembleKalmanProcess.constrained_gaussian function.","category":"page"},{"location":"quickstart/#Implementing-your-experiment","page":"Getting Started","title":"Implementing your experiment","text":"","category":"section"},{"location":"quickstart/#Forward-Model","page":"Getting Started","title":"Forward Model","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Your forward model must implement the forward_model(iteration, member)  function stub.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Since this function only takes in the iteration and member numbers, there are some  hooks to obtain parameters and the output directory:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"path_to_ensemble_member returns the ensemble member's output directory, ","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"which can be used to set the forward model's output directory.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"parameter_path returns the ensemble member's parameter file, which can ","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"be loaded in via TOML or passed to ClimaParams.","category":"page"},{"location":"quickstart/#Observational-data","page":"Getting Started","title":"Observational data","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Observational data generally consists of a vector of observations with length d  and the covariance matrix of the observational noise with size d × d.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"If you need to stack or sample from observations, EnsembleKalmanProcesses.jl's  Observation  or ObservationSeries are fully-featured.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"An observation map to process model output and return the full ensemble's observations is also required.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"This is provided by implementing the function stub observation_map(iteration). This function needs to return an Array arr where arr[:, i] will return the i-th ensemble member's observational output.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Here is a readable template for the observation_map","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"function observation_map(iteration)\n    single_observation_dims = 1\n    G_ensemble = Array{Float64}(undef, single_observation_dims..., ensemble_size)\n    for member in 1:ensemble_size\n        G_ensemble[:, member] = process_member_data(iteration, member)\n    end\n    return G_ensemble\nend","category":"page"},{"location":"quickstart/#Optional-postprocessing","page":"Getting Started","title":"Optional postprocessing","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"It may be the case that observation_map is insufficient as you need to more information, such as information from the ekp object to compute G_ensemble. Further postprocessing of the G_ensemble object can be done by implementing the postprocess_g_ensemble as shown below.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"function postprocess_g_ensemble(ekp, g_ensemble, prior, output_dir, iteration)\n    return g_ensemble\nend","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"After each evaluation of the observation map and before updating the ensemble, it may be helpful to print the errors from the ekp object or plot G_ensemble. This can be done by implementing the analyze_iteration as shown below.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"function ClimaCalibrate.analyze_iteration(\n    ekp,\n    g_ensemble,\n    prior,\n    output_dir,\n    iteration,\n)\n    @info \"Analyzing iteration\"\n    @info \"Iteration $iteration\"\n    @info \"Current mean parameter: $(EnsembleKalmanProcesses.get_ϕ_mean_final(prior, ekp))\"\n    @info \"g_ensemble: $g_ensemble\"\n    @info \"output_dir: $output_dir\"\n    return nothing\nend","category":"page"},{"location":"quickstart/#Parameters","page":"Getting Started","title":"Parameters","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Every parameter that is being calibrated requires a prior distribution to sample from.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"EnsembleKalmanProcesses.jl's constrained_gaussian  provides a user-friendly way to constructor Gaussian distributions.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Multiple distributions can be combined using combine_distributions(vec_of_distributions).","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"For more information, see the EKP documentation for prior distributions.","category":"page"},{"location":"quickstart/#Experiment-Configuration","page":"Getting Started","title":"Experiment Configuration","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"A calibration consisting of m ensemble members will run for n iterations.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"A good rule of thumb is an ensemble size 10 times the number of parameters.","category":"page"},{"location":"quickstart/#Calibrate","page":"Getting Started","title":"Calibrate","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Now all of the pieces should be in place:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"forward map\nobservation map\nobservations\ncovariance matrix of the observations (noise)\nprior distribution\nensemble size\nnumber of iterations","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"And we can put it all together:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"calibrate(ensemble_size, n_iterations, observations, noise, prior, output_dir)","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Lastly, you need to set the output directory, ensemble size and the number of iterations to run for. A good rule of thumb for your ensemble size is 10x the number of free parameters.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"n_iterations = 7\nensemble_size = 10\noutput_dir = \"output/my_experiment\"","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Once all of this has been set up, you can call put it all together using the calibrate function:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"calibrate(ensemble_size, n_iterations, observations, noise, prior, output_dir)","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"For more information on parallelizing your calibration, see the Backends page.","category":"page"},{"location":"quickstart/#Checkpointing","page":"Getting Started","title":"Checkpointing","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"ClimaCalibrate checkpoints each forward model and iteration so that an interrupted calibration can seamlessly pick up where it left off without wasting resources.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"If a calibration (run via calibrate) exits after completing an iteration,  when it is restarted it will automatically run the next iteration.  This is done by checking if the ensemble forward map results file (G_ensemble.jld2)  and the EKI file (eki_file.jld2) have been saved.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"If a calibration is interrupted during forward model execution,  causing a partial iteration, incomplete forward models will be rerun when the  calibration is restarted. Completed forward models will not be rerun. This is done by checking each model's checkpoint file and the flag it contains.","category":"page"},{"location":"quickstart/#Example-Calibrations","page":"Getting Started","title":"Example Calibrations","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"The example tutorial provides a clear calibration example that can be run locally.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Another example experiment can be found in the package repo under experiments/surface_fluxes_perfect_model. This experiment uses the SurfaceFluxes.jl package  to generate a physical model that calculates the Monin Obukhov turbulent surface  fluxes based on idealized atmospheric and surface conditions. Since this is a \"perfect  model\" example, the same model is used to generate synthetic observations using its  default parameters and a small amount of noise. These synthetic observations are  considered to be the ground truth, which is used to assess the model ensembles'  performance when parameters are drawn from the prior parameter distributions. ","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"It is a perfect-model calibration, using its own output as observational data.  By default, it runs 20 ensemble members for 6 iterations.  This example can be run on the most common backend, the WorkerBackend, with the following script:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"using ClimaCalibrate\n\ninclude(joinpath(pkgdir(ClimaCalibrate), \"experiments\", \"surface_fluxes_perfect_model\", \"utils.jl\"))\n@show ensemble_size n_iterations observation variance prior\n\neki = calibrate(\n    ensemble_size,\n    n_iterations,\n    observation,\n    variance,\n    prior,\n    output_dir,\n)\n\ntheta_star_vec =\n    (; coefficient_a_m_businger = 4.7, coefficient_a_h_businger = 4.7)\n\nconvergence_plot(\n    eki,\n    prior,\n    theta_star_vec,\n    [\"coefficient_a_m_businger\", \"coefficient_a_h_businger\"],\n)\n\ng_vs_iter_plot(eki)","category":"page"},{"location":"observations/#Observations","page":"Observations","title":"Observations","text":"","category":"section"},{"location":"observations/","page":"Observations","title":"Observations","text":"Robust observations and accurate error covariances are essential for successful calibration. When calibrating climate models, it is advisable to use long-term climate statistics, such as monthly or seasonal averages, to reduce the influence of internal variability. This results in a more stable and representative target for inversion.","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"EnsembleKalmanProcesses.jl provides several containers for managing observations, with documentation provided here. As inputs to a calibration, observations can consist of a Vector, an EKP.Observation (a single observation), or an EKP.ObservationSeries (many observations).","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"To iterate through an EKP.ObservationSeries, you must provide a minibatcher. This package provides two helper functions to faciliate the creation of simple batches:","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"ClimaCalibrate.minibatcher_over_samples takes in samples or (a number of samples) and a batch size and returns a minibatcher which divides the samples into the batch size, dropping remaining samples.\nClimaCalibrate.observation_series_from_samples takes in a vector of Observations and a batch size and returns an ObservationSeries with a minibatcher.","category":"page"},{"location":"precompilation/#Using-PrecompileTools-for-faster-model-runs","page":"Using PrecompileTools for faster model runs","title":"Using PrecompileTools for faster model runs","text":"","category":"section"},{"location":"precompilation/","page":"Using PrecompileTools for faster model runs","title":"Using PrecompileTools for faster model runs","text":"PrecompileTools.jl enables developers to force the Julia compiler to save more code to disk, preventing re-compilation in the future.","category":"page"},{"location":"precompilation/","page":"Using PrecompileTools for faster model runs","title":"Using PrecompileTools for faster model runs","text":"For ClimaCalibrate, this is useful under certain conditions:","category":"page"},{"location":"precompilation/","page":"Using PrecompileTools for faster model runs","title":"Using PrecompileTools for faster model runs","text":"The atmosphere model configuration is set and will not change often. This is because the model configuration specifies things like the floating-point type and callbacks, which affect the MethodInstances that get precompiled. Generically precompiling ClimaAtmos would take much too long to be useful.\nThe model runtime is short compared to the compile time. If the model runtime is an order of magnitude or more than the compilation time, any benefit from reduced compilation time will be trivial.","category":"page"},{"location":"precompilation/#How-do-I-precompile-my-configuration?","page":"Using PrecompileTools for faster model runs","title":"How do I precompile my configuration?","text":"","category":"section"},{"location":"precompilation/","page":"Using PrecompileTools for faster model runs","title":"Using PrecompileTools for faster model runs","text":"The easiest way is by copying and pasting the code snippet below into src/ClimaCalibrate.jl. This will precompile the model step and all callbacks for the given configuration.","category":"page"},{"location":"precompilation/","page":"Using PrecompileTools for faster model runs","title":"Using PrecompileTools for faster model runs","text":"using PrecompileTools\nimport SciMLBase\nimport ClimaAtmos as CA\nimport YAML\n\n@setup_workload begin\n    config_file = Dict(\"FLOAT_TYPE\" => \"Float64\")\n    @compile_workload begin\n        config = CA.AtmosConfig(config_dict)\n        simulation = CA.get_simulation(config)\n        (; integrator) = simulation\n        SciMLBase.step!(integrator)\n        CA.call_all_callbacks!(integrator)\n    end\nend","category":"page"},{"location":"backends/#Backends","page":"Backends","title":"Backends","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"ClimaCalibrate can scale calibrations on different distributed computing environments, referred to as backends. Each backend is optimized for specific use cases and computing resources. The backend system is implemented through Julia's multiple dispatch, allowing seamless switching between different computing environments.","category":"page"},{"location":"backends/#Available-Backends","page":"Backends","title":"Available Backends","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"JuliaBackend: The simplest backend that runs everything serially on a single machine. Best for initial testing and small calibrations that do not require parallelization. \nWorkerBackend: Uses Julia's built-in distributed computing capabilities, assigning forward model runs to separate workers using Distributed.jl. Workers can be created using SlurmManager, Distributed.addprocs, or by initializing julia with the -p option: julia -p 2. Available workers can be accessed using Distributed.workers().\nHPC Cluster Backends: These backends schedule forward model runs on HPC clusters using Slurm or PBS.\nCaltechHPCBackend: Caltech's Resnick HPC cluster\nClimaGPUBackend: CliMA's private GPU server\nDerechoBackend: NSF NCAR Derecho supercomputing system.","category":"page"},{"location":"backends/#Choosing-the-Right-Backend","page":"Backends","title":"Choosing the Right Backend","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"The right backend is largely determined by the computational cost of your forward model.","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"If your model is very simple or you are debugging, use the JuliaBackend.","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"If your model requires just one CPU core or GPU, the best backend is the WorkerBackend. ","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"If your forward model requires parallelization across multiple cores or GPUs, choose one of the HPC Cluster backends. These allow you allocate more resources to each forward model using Slurm or PBS.","category":"page"},{"location":"backends/#Using-a-Backend","page":"Backends","title":"Using a Backend","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"Backends are the first argument to the calibrate function, which runs iterations of the forward model, updating model parameter based on observations.","category":"page"},{"location":"#ClimaCalibrate.jl","page":"Home","title":"ClimaCalibrate.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimaCalibrate provides a scalable framework for calibrating forward models models using  the Ensemble Kalman Process (EKP). It integrates with EnsembleKalmanProcesses.jl  to enable distributed model calibration with minimal boilerplate code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Key Features","category":"page"},{"location":"","page":"Home","title":"Home","text":"Distributed computing support for multiple HPC environments\nIntegration with EnsembleKalmanProcesses.jl for parameter estimation\nFlexible model interface for different component models\nSupport for emulation and sampling workflows","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information, see our Getting Started page.","category":"page"}]
}
