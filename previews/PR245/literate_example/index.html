<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distributed Calibration Tutorial · ClimaCalibrate.jl</title><meta name="title" content="Distributed Calibration Tutorial · ClimaCalibrate.jl"/><meta property="og:title" content="Distributed Calibration Tutorial · ClimaCalibrate.jl"/><meta property="twitter:title" content="Distributed Calibration Tutorial · ClimaCalibrate.jl"/><meta name="description" content="Documentation for ClimaCalibrate.jl."/><meta property="og:description" content="Documentation for ClimaCalibrate.jl."/><meta property="twitter:description" content="Documentation for ClimaCalibrate.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCalibrate.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Distributed Calibration Tutorial</a></li><li><a class="tocitem" href="../backends/">Backends</a></li><li><a class="tocitem" href="../submit_scripts/">Submission Scripts</a></li><li><a class="tocitem" href="../observations/">Observations</a></li><li><a class="tocitem" href="../observation_recipe/">Observation Recipes</a></li><li><a class="tocitem" href="../ensemble_builder/">G Ensemble Builder</a></li><li><a class="tocitem" href="../emulate_sample/">Emulate and Sample</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Distributed Calibration Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Distributed Calibration Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCalibrate.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCalibrate.jl/blob/main/docs/literate_example.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Distributed-Calibration-Tutorial-Using-Julia-Workers"><a class="docs-heading-anchor" href="#Distributed-Calibration-Tutorial-Using-Julia-Workers">Distributed Calibration Tutorial Using Julia Workers</a><a id="Distributed-Calibration-Tutorial-Using-Julia-Workers-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed-Calibration-Tutorial-Using-Julia-Workers" title="Permalink"></a></h1><p>This example will teach you how to use ClimaCalibrate to parallelize your calibration with workers. Workers are additional processes spun up to run code in a distributed fashion. In this tutorial, we will run ensemble members&#39; forward models on different workers.</p><p>The example calibration uses CliMA&#39;s atmosphere model, <a href="https://github.com/CliMA/ClimaAtmos.jl/"><code>ClimaAtmos.jl</code></a>, in a column spatial configuration for 30 days to simulate outgoing radiative fluxes. Radiative fluxes are used in the observation map to calibrate the astronomical unit.</p><p>First, we load in some necessary packages.</p><pre><code class="language-julia hljs">using Distributed
import ClimaCalibrate as CAL
import ClimaAnalysis: SimDir, get, slice, average_xy
using ClimaUtilities.ClimaArtifacts
import EnsembleKalmanProcesses: I, ParameterDistributions.constrained_gaussian</code></pre><p>Next, we add workers. These are primarily added by <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/#Distributed.addprocs"><code>Distributed.addprocs</code></a> or by starting Julia with multiple processes: <code>julia -p &lt;nprocs&gt;</code>.</p><p><code>addprocs</code> itself initializes the workers and registers them with the main Julia process, but there are multiple ways to call it. The simplest is just <code>addprocs(nprocs)</code>, which will create new local processes on your machine. The other is to use <a href="../api/#ClimaCalibrate.SlurmManager"><code>SlurmManager</code></a>, which will acquire and start workers on Slurm resources. You can use keyword arguments to specify the Slurm resources:</p><p><code>addprocs(ClimaCalibrate.SlurmManager(nprocs), gpus_per_task = 1, time = &quot;01:00:00&quot;)</code></p><p>For this example, we would add one worker if it was compatible with Documenter.jl:</p><pre><code class="language-julia hljs">addprocs(1)</code></pre><p>We can see the number of workers and their ID numbers:</p><pre><code class="language-julia hljs">nworkers()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><pre><code class="language-julia hljs">workers()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Int64}:
 1</code></pre><p>We can call functions on the worker using <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/#Distributed.remotecall_fetch-Tuple{Any,%20Integer,%20Vararg{Any}}"><code>remotecall</code></a>. We pass in the function name and the worker ID followed by the function arguments.</p><pre><code class="language-julia hljs">remotecall_fetch(*, 1, 4, 4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">16</code></pre><p>ClimaCalibrate uses this functionality to run the forward model on workers.</p><p>Since the workers start in their own Julia sessions, we need to import packages and declare variables. <code>Distributed.@everywhere</code> executes code on all workers, allowing us to load the code that they need.</p><pre><code class="language-julia hljs">@everywhere begin
    output_dir = joinpath(&quot;output&quot;, &quot;climaatmos_calibration&quot;)
    import ClimaCalibrate as CAL
    import ClimaAtmos as CA
    import ClimaComms
end
output_dir = joinpath(&quot;output&quot;, &quot;climaatmos_calibration&quot;)
mkpath(output_dir)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;output/climaatmos_calibration&quot;</code></pre><p>First, we need to set up the forward model, which take in the sampled parameters, runs, and saves diagnostic output that can be processed and compared to observations. The forward model must override <code>ClimaCalibrate.forward_model(iteration, member)</code>, since the workers will run this function in parallel.</p><p>Since <code>forward_model(iteration, member)</code> only takes in the iteration and member numbers, so we need to use these as hooks to set the model parameters and output directory. Two useful functions:</p><ul><li><a href="../api/#ClimaCalibrate.path_to_ensemble_member"><code>path_to_ensemble_member</code></a>: Returns the ensemble member&#39;s output directory</li><li><a href="../api/#ClimaCalibrate.parameter_path"><code>parameter_path</code></a>: Returns the ensemble member&#39;s parameter file as specified by <a href="https://clima.github.io/EnsembleKalmanProcesses.jl/dev/API/TOMLInterface/#EnsembleKalmanProcesses.TOMLInterface.save_parameter_ensemble"><code>EKP.TOMLInterface</code></a></li></ul><p>The forward model below is running <code>ClimaAtmos.jl</code> in a minimal <code>column</code> spatial configuration.</p><pre><code class="language-julia hljs">@everywhere function CAL.forward_model(iteration, member)
    config_dict = Dict(
        &quot;dt&quot; =&gt; &quot;2000secs&quot;,
        &quot;t_end&quot; =&gt; &quot;30days&quot;,
        &quot;config&quot; =&gt; &quot;column&quot;,
        &quot;h_elem&quot; =&gt; 1,
        &quot;insolation&quot; =&gt; &quot;timevarying&quot;,
        &quot;output_dir&quot; =&gt; output_dir,
        &quot;output_default_diagnostics&quot; =&gt; false,
        &quot;dt_rad&quot; =&gt; &quot;6hours&quot;,
        &quot;rad&quot; =&gt; &quot;clearsky&quot;,
        &quot;co2_model&quot; =&gt; &quot;fixed&quot;,
        &quot;log_progress&quot; =&gt; false,
        &quot;diagnostics&quot; =&gt; [
            Dict(
                &quot;reduction_time&quot; =&gt; &quot;average&quot;,
                &quot;short_name&quot; =&gt; &quot;rsut&quot;,
                &quot;period&quot; =&gt; &quot;30days&quot;,
                &quot;writer&quot; =&gt; &quot;nc&quot;,
            ),
        ],
    )
    #md # Set the output path for the current member
    member_path = CAL.path_to_ensemble_member(output_dir, iteration, member)
    config_dict[&quot;output_dir&quot;] = member_path

    #md # Set the parameters for the current member
    parameter_path = CAL.parameter_path(output_dir, iteration, member)
    if haskey(config_dict, &quot;toml&quot;)
        push!(config_dict[&quot;toml&quot;], parameter_path)
    else
        config_dict[&quot;toml&quot;] = [parameter_path]
    end

    #md # Turn off default diagnostics
    config_dict[&quot;output_default_diagnostics&quot;] = false

    comms_ctx = ClimaComms.SingletonCommsContext()
    atmos_config = CA.AtmosConfig(config_dict; comms_ctx)
    simulation = CA.get_simulation(atmos_config)
    CA.solve_atmos!(simulation)
    return simulation
end</code></pre><p>Next, the observation map is required to process a full ensemble of model output for the ensemble update step. The observation map just takes in the iteration number, and always outputs an array. For observation map output <code>G_ensemble</code>, <code>G_ensemble[:, m]</code> must the output of ensemble member <code>m</code>. This is needed for compatibility with EnsembleKalmanProcesses.jl.</p><pre><code class="language-julia hljs">const days = 86_400
function CAL.observation_map(iteration)
    single_member_dims = (1,)
    G_ensemble = Array{Float64}(undef, single_member_dims..., ensemble_size)

    for m in 1:ensemble_size
        member_path = CAL.path_to_ensemble_member(output_dir, iteration, m)
        simdir_path = joinpath(member_path, &quot;output_active&quot;)
        if isdir(simdir_path)
            simdir = SimDir(simdir_path)
            G_ensemble[:, m] .= process_member_data(simdir)
        else
            G_ensemble[:, m] .= NaN
        end
    end
    return G_ensemble
end</code></pre><p>Separating out the individual ensemble member output processing often results in more readable code.</p><pre><code class="language-julia hljs">function process_member_data(simdir::SimDir)
    isempty(simdir.vars) &amp;&amp; return NaN
    rsut =
        get(simdir; short_name = &quot;rsut&quot;, reduction = &quot;average&quot;, period = &quot;30d&quot;)
    return slice(average_xy(rsut); time = 30days).data
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">process_member_data (generic function with 1 method)</code></pre><p>Now, we can set up the remaining experiment details:</p><ul><li>ensemble size, number of iterations</li><li>the prior distribution</li><li>the observational data</li></ul><pre><code class="language-julia hljs">ensemble_size = 30
n_iterations = 7
noise = 0.1 * I
prior = constrained_gaussian(&quot;astronomical_unit&quot;, 6e10, 1e11, 2e5, Inf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ParameterDistribution with 1 entries: 
&#39;astronomical_unit&#39; with EnsembleKalmanProcesses.ParameterDistributions.Constraint{EnsembleKalmanProcesses.ParameterDistributions.BoundedBelow}[Bounds: (200000.0, ∞)] over distribution EnsembleKalmanProcesses.ParameterDistributions.Parameterized(Distributions.Normal{Float64}(μ=24.153036641203013, σ=1.1528837102037748)) 
</code></pre><p>For a perfect model, we generate observations from the forward model itself. This is most easily done by creating an empty parameter file and running the 0th ensemble member:</p><pre><code class="language-julia hljs">@info &quot;Generating observations&quot;
parameter_file = CAL.parameter_path(output_dir, 0, 0)
mkpath(dirname(parameter_file))
touch(parameter_file)
simulation = CAL.forward_model(0, 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulation 
├── Running on: CPUSingleThreaded
├── Output folder: output/climaatmos_calibration/iteration_000/member_000/output_0000
├── Start date: 2010-01-01T00:00:00
├── Current time: 2.592e6 seconds
└── Stop time: 2.592e6 seconds</code></pre><p>Lastly, we use the observation map itself to generate the observations.</p><pre><code class="language-julia hljs">observations = Vector{Float64}(undef, 1)
observations .= process_member_data(SimDir(simulation.output_dir))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 126.61351013183594</code></pre><p>Now we are ready to run our calibration, putting it all together using the <code>calibrate</code> function. The <code>WorkerBackend</code> will automatically use all workers available to the main Julia process. Other backends are available for forward models that can&#39;t use workers or need to be parallelized internally. The simplest backend is the <code>JuliaBackend</code>, which runs all ensemble members sequentially and does not require <code>Distributed.jl</code>. For more information, see the <a href="https://clima.github.io/ClimaCalibrate.jl/dev/backends/"><code>Backends</code></a> page.</p><pre><code class="language-julia hljs">eki = CAL.calibrate(
    CAL.WorkerBackend(),
    ensemble_size,
    n_iterations,
    observations,
    noise,
    prior,
    output_dir,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleKalmanProcesses.EnsembleKalmanProcess{Float64, Int64, EnsembleKalmanProcesses.Inversion{Float64, Nothing, Nothing}, EnsembleKalmanProcesses.DataMisfitController{Float64, String}, EnsembleKalmanProcesses.NesterovAccelerator{Float64}, Vector{EnsembleKalmanProcesses.UpdateGroup}, Nothing}(EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}[EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.152987101423427 23.113430885124696 … 23.79546679184483 23.458185685100936]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.314276905893873 23.347564142422026 … 24.02594727553402 23.691073689905483]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.806357639642773 24.21042913412302 … 24.867453634729316 24.546621989140785]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.707197484227514 25.15163604046828 … 25.689309709411802 25.445787567121485]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.749029520190263 25.924325043573546 … 25.920329964215963 25.995005438252914]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.73465636643261 25.849012706337763 … 25.732346077941965 25.725183467494524]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.730954668897994 25.772177917956675 … 25.730535903497543 25.740530116777904]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.730352390174293 25.737564207268974 … 25.730545868369568 25.738217554317494])], EnsembleKalmanProcesses.ObservationSeries{Vector{EnsembleKalmanProcesses.Observation{Vector{Vector{Float64}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{String}, Vector{UnitRange{Int64}}, Nothing}}, EnsembleKalmanProcesses.FixedMinibatcher{Vector{Vector{Int64}}, String, Random.TaskLocalRNG}, Vector{String}, Vector{Vector{Vector{Int64}}}, Nothing}(EnsembleKalmanProcesses.Observation{Vector{Vector{Float64}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{String}, Vector{UnitRange{Int64}}, Nothing}[EnsembleKalmanProcesses.Observation{Vector{Vector{Float64}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{String}, Vector{UnitRange{Int64}}, Nothing}([[126.61351013183594]], LinearAlgebra.Diagonal{Float64, Vector{Float64}}[[0.1;;]], LinearAlgebra.Diagonal{Float64, Vector{Float64}}[[10.0;;]], [&quot;observation&quot;], UnitRange{Int64}[1:1], nothing)], EnsembleKalmanProcesses.FixedMinibatcher{Vector{Vector{Int64}}, String, Random.TaskLocalRNG}([[1]], &quot;order&quot;, Random.TaskLocalRNG()), [&quot;series_1&quot;], Dict(&quot;minibatch&quot; =&gt; 1, &quot;epoch&quot; =&gt; 8), [[[1]], [[1]], [[1]], [[1]], [[1]], [[1]], [[1]], [[1]]], nothing), 30, EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}[EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([39.85676574707031 0.6747428178787231 … 2.6395461559295654 1.3445560932159424]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([55.022071838378906 1.0777157545089722 … 4.185122966766357 2.1422007083892822]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([147.12294006347656 6.052626132965088 … 22.51983070373535 11.855969429016113]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([120.67707061767578 39.74935531616211 … 116.44346618652344 71.56816101074219]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([131.20321655273438 186.22613525390625 … 184.7446746826172 214.46112060546875]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([127.48693084716797 160.213623046875 … 126.89714050292969 125.0970458984375]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([126.54457092285156 137.4112548828125 … 126.44273376464844 128.991455078125])], Dict(&quot;unweighted_loss&quot; =&gt; [4670.416796232371, 10300.047564037592, 4942.639456067157, 316.70897228077126, 209.53974545009214, 76.44551267218199, 3.081283928360868], &quot;crps&quot; =&gt; [51.10421697975316, 79.00523623025258, 44.94296474373018, 15.32997777290889, 12.822134985823906, 9.28714164737906, 3.2180297503898916], &quot;bayes_loss&quot; =&gt; [46704.17826324709, 103000.9095856978, 49427.63112090413, 3168.783007530492, 2097.132561074044, 766.1976739568869, 32.57994106112107], &quot;unweighted_avg_rmse&quot; =&gt; [140.6212959173834, 104.56913553685881, 76.70374405160547, 44.983187351624174, 35.466037015120186, 17.443662643432617, 5.931475575764974], &quot;avg_rmse&quot; =&gt; [3178.874617078112, 1885.8938531140104, 1516.5623420940844, 1002.6932945314294, 844.8214032517922, 633.9280348707905, 229.83178046266863], &quot;loss&quot; =&gt; [46704.16796232371, 103000.47564037591, 49426.39456067158, 3167.089722807713, 2095.3974545009214, 764.4551267218199, 30.812839283608678]), EnsembleKalmanProcesses.DataMisfitController{Float64, String}([7], 1.0, &quot;stop&quot;), EnsembleKalmanProcesses.NesterovAccelerator{Float64}([25.731126365541183 25.74528557969135 … 25.73096123081728 25.734607722671843], 0.20434762801820305), [2.968755677884909e-6, 2.8039530661142667e-5, 2.346918612260593e-5, 3.165392838160827e-5, 4.203310170863153e-5, 7.465198116168663e-5, 0.0005679382145233179], EnsembleKalmanProcesses.UpdateGroup[EnsembleKalmanProcesses.UpdateGroup([1], [1], Dict(&quot;[1,...,1]&quot; =&gt; &quot;[1,...,1]&quot;))], EnsembleKalmanProcesses.Inversion{Float64, Nothing, Nothing}(nothing, nothing, false, 0.0), Random.MersenneTwister(1234, (0, 1002, 0, 245)), EnsembleKalmanProcesses.FailureHandler{EnsembleKalmanProcesses.Inversion, EnsembleKalmanProcesses.SampleSuccGauss}(EnsembleKalmanProcesses.var&quot;#failsafe_update#174&quot;()), EnsembleKalmanProcesses.Localizers.Localizer{EnsembleKalmanProcesses.Localizers.SECNice, Float64}(EnsembleKalmanProcesses.Localizers.var&quot;#13#14&quot;{EnsembleKalmanProcesses.Localizers.SECNice{Float64}}(EnsembleKalmanProcesses.Localizers.SECNice{Float64}(1000, 1.0, 1.0))), 0.1, nothing, false)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Getting Started</a><a class="docs-footer-nextpage" href="../backends/">Backends »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 20 October 2025 16:57">Monday 20 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
