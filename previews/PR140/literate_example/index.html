<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distributed Calibration Tutorial · ClimaCalibrate.jl</title><meta name="title" content="Distributed Calibration Tutorial · ClimaCalibrate.jl"/><meta property="og:title" content="Distributed Calibration Tutorial · ClimaCalibrate.jl"/><meta property="twitter:title" content="Distributed Calibration Tutorial · ClimaCalibrate.jl"/><meta name="description" content="Documentation for ClimaCalibrate.jl."/><meta property="og:description" content="Documentation for ClimaCalibrate.jl."/><meta property="twitter:description" content="Documentation for ClimaCalibrate.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCalibrate.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Distributed Calibration Tutorial</a></li><li><a class="tocitem" href="../backends/">Backends</a></li><li><a class="tocitem" href="../emulate_sample/">Emulate and Sample</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Distributed Calibration Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Distributed Calibration Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCalibrate.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCalibrate.jl/blob/main/docs/literate_example.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Distributed-Calibration-Tutorial-Using-Julia-Workers"><a class="docs-heading-anchor" href="#Distributed-Calibration-Tutorial-Using-Julia-Workers">Distributed Calibration Tutorial Using Julia Workers</a><a id="Distributed-Calibration-Tutorial-Using-Julia-Workers-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed-Calibration-Tutorial-Using-Julia-Workers" title="Permalink"></a></h1><p>This example will teach you how to use ClimaCalibrate to parallelize your calibration with workers. Workers are additional processes spun up to run code in a distributed fashion. In this tutorial, we will run ensemble members&#39; forward models on different workers.</p><p>The example calibration uses CliMA&#39;s atmosphere model, <a href="https://github.com/CliMA/ClimaAtmos.jl/"><code>ClimaAtmos.jl</code></a>, in a column spatial configuration for 30 days to simulate outgoing radiative fluxes. Radiative fluxes are used in the observation map to calibrate the astronomical unit.</p><p>First, we load in some necessary packages.</p><pre><code class="language-julia hljs">using Distributed
import ClimaCalibrate as CAL
import ClimaAnalysis: SimDir, get, slice, average_xy
using ClimaUtilities.ClimaArtifacts
import EnsembleKalmanProcesses: I, ParameterDistributions.constrained_gaussian</code></pre><p>Next, we add workers. These are primarily added by <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/#Distributed.addprocs"><code>Distributed.addprocs</code></a> or by starting Julia with multiple processes: <code>julia -p &lt;nprocs&gt;</code>.</p><p><code>addprocs</code> itself initializes the workers and registers them with the main Julia process, but there are multiple ways to call it. The simplest is just <code>addprocs(nprocs)</code>, which will create new local processes on your machine. The other is to use <a href="../api/#ClimaCalibrate.SlurmManager"><code>SlurmManager</code></a>, which will acquire and start workers on Slurm resources. You can use keyword arguments to specify the Slurm resources:</p><p><code>addprocs(ClimaCalibrate.SlurmManager(nprocs), gpus_per_task = 1, time = &quot;01:00:00&quot;)</code></p><p>For this example, we would add one worker if it was compatible with Documenter.jl:</p><pre><code class="language-julia hljs">addprocs(1)</code></pre><p>We can see the number of workers and their ID numbers:</p><pre><code class="language-julia hljs">nworkers()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><pre><code class="language-julia hljs">workers()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Int64}:
 1</code></pre><p>We can call functions on the worker using <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/#Distributed.remotecall_fetch-Tuple{Any,%20Integer,%20Vararg{Any}}"><code>remotecall</code></a>. We pass in the function name and the worker ID followed by the function arguments.</p><pre><code class="language-julia hljs">remotecall_fetch(*, 1, 4, 4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">16</code></pre><p>ClimaCalibrate uses this functionality to run the forward model on workers.</p><p>Since the workers start in their own Julia sessions, we need to import packages and declare variables. <code>Distributed.@everywhere</code> executes code on all workers, allowing us to load the code that they need.</p><pre><code class="language-julia hljs">@everywhere begin
    output_dir = joinpath(&quot;output&quot;, &quot;climaatmos_calibration&quot;)
    import ClimaCalibrate as CAL
    import ClimaAtmos as CA
    import ClimaComms
end
output_dir = joinpath(&quot;output&quot;, &quot;climaatmos_calibration&quot;)
mkpath(output_dir)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;output/climaatmos_calibration&quot;</code></pre><p>First, we need to set up the forward model, which take in the sampled parameters, runs, and saves diagnostic output that can be processed and compared to observations. The forward model must override <code>ClimaCalibrate.forward_model(iteration, member)</code>, since the workers will run this function in parallel.</p><p>Since <code>forward_model(iteration, member)</code> only takes in the iteration and member numbers, so we need to use these as hooks to set the model parameters and output directory. Two useful functions:</p><ul><li><a href="../api/#ClimaCalibrate.path_to_ensemble_member"><code>path_to_ensemble_member</code></a>: Returns the ensemble member&#39;s output directory</li><li><a href="../api/#ClimaCalibrate.parameter_path"><code>parameter_path</code></a>: Returns the ensemble member&#39;s parameter file as specified by <a href="https://clima.github.io/EnsembleKalmanProcesses.jl/dev/API/TOMLInterface/#EnsembleKalmanProcesses.TOMLInterface.save_parameter_ensemble"><code>EKP.TOMLInterface</code></a></li></ul><p>The forward model below is running <code>ClimaAtmos.jl</code> in a minimal <code>column</code> spatial configuration.</p><pre><code class="language-julia hljs">@everywhere function CAL.forward_model(iteration, member)
    config_dict = Dict(
        &quot;dt&quot; =&gt; &quot;2000secs&quot;,
        &quot;t_end&quot; =&gt; &quot;30days&quot;,
        &quot;config&quot; =&gt; &quot;column&quot;,
        &quot;h_elem&quot; =&gt; 1,
        &quot;insolation&quot; =&gt; &quot;timevarying&quot;,
        &quot;output_dir&quot; =&gt; output_dir,
        &quot;output_default_diagnostics&quot; =&gt; false,
        &quot;dt_rad&quot; =&gt; &quot;6hours&quot;,
        &quot;rad&quot; =&gt; &quot;clearsky&quot;,
        &quot;co2_model&quot; =&gt; &quot;fixed&quot;,
        &quot;log_progress&quot; =&gt; false,
        &quot;diagnostics&quot; =&gt; [
            Dict(
                &quot;reduction_time&quot; =&gt; &quot;average&quot;,
                &quot;short_name&quot; =&gt; &quot;rsut&quot;,
                &quot;period&quot; =&gt; &quot;30days&quot;,
                &quot;writer&quot; =&gt; &quot;nc&quot;,
            ),
        ],
    )
    #md # Set the output path for the current member
    member_path = CAL.path_to_ensemble_member(output_dir, iteration, member)
    config_dict[&quot;output_dir&quot;] = member_path

    #md # Set the parameters for the current member
    parameter_path = CAL.parameter_path(output_dir, iteration, member)
    if haskey(config_dict, &quot;toml&quot;)
        push!(config_dict[&quot;toml&quot;], parameter_path)
    else
        config_dict[&quot;toml&quot;] = [parameter_path]
    end

    #md # Turn off default diagnostics
    config_dict[&quot;output_default_diagnostics&quot;] = false

    comms_ctx = ClimaComms.SingletonCommsContext()
    atmos_config = CA.AtmosConfig(config_dict; comms_ctx)
    simulation = CA.get_simulation(atmos_config)
    CA.solve_atmos!(simulation)
    return simulation
end</code></pre><p>Next, the observation map is required to process a full ensemble of model output for the ensemble update step. The observation map just takes in the iteration number, and always outputs an array. For observation map output <code>G_ensemble</code>, <code>G_ensemble[:, m]</code> must the output of ensemble member <code>m</code>. This is needed for compatability with EnsembleKalmanProcesses.jl.</p><pre><code class="language-julia hljs">const days = 86_400
function CAL.observation_map(iteration)
    single_member_dims = (1,)
    G_ensemble = Array{Float64}(undef, single_member_dims..., ensemble_size)

    for m in 1:ensemble_size
        member_path = CAL.path_to_ensemble_member(output_dir, iteration, m)
        simdir_path = joinpath(member_path, &quot;output_active&quot;)
        if isdir(simdir_path)
            simdir = SimDir(simdir_path)
            G_ensemble[:, m] .= process_member_data(simdir)
        else
            G_ensemble[:, m] .= NaN
        end
    end
    return G_ensemble
end</code></pre><p>Separating out the individual ensemble member output processing often results in more readable code.</p><pre><code class="language-julia hljs">function process_member_data(simdir::SimDir)
    isempty(simdir.vars) &amp;&amp; return NaN
    rsut =
        get(simdir; short_name = &quot;rsut&quot;, reduction = &quot;average&quot;, period = &quot;30d&quot;)
    return slice(average_xy(rsut); time = 30days).data
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">process_member_data (generic function with 1 method)</code></pre><p>Now, we can set up the remaining experiment details:</p><ul><li>ensemble size, number of iterations</li><li>the prior distribution</li><li>the observational data</li></ul><pre><code class="language-julia hljs">ensemble_size = 30
n_iterations = 7
noise = 0.1 * I
prior = constrained_gaussian(&quot;astronomical_unit&quot;, 6e10, 1e11, 2e5, Inf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ParameterDistribution with 1 entries: 
&#39;astronomical_unit&#39; with EnsembleKalmanProcesses.ParameterDistributions.Constraint{EnsembleKalmanProcesses.ParameterDistributions.BoundedBelow}[Bounds: (200000.0, ∞)] over distribution EnsembleKalmanProcesses.ParameterDistributions.Parameterized(Distributions.Normal{Float64}(μ=24.153036641203013, σ=1.1528837102037748)) 
</code></pre><p>For a perfect model, we generate observations from the forward model itself. This is most easily done by creating an empty parameter file and running the 0th ensemble member:</p><pre><code class="language-julia hljs">@info &quot;Generating observations&quot;
parameter_file = CAL.parameter_path(output_dir, 0, 0)
mkpath(dirname(parameter_file))
touch(parameter_file)
simulation = CAL.forward_model(0, 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulation 
├── Running on: CPUSingleThreaded
├── Output folder: output/climaatmos_calibration/iteration_000/member_000/output_0000
├── Start date: 2010-01-01T00:00:00
├── Current time: 2.592e6 seconds
└── Stop time: 2.592e6 seconds</code></pre><p>Lastly, we use the observation map itself to generate the observations.</p><pre><code class="language-julia hljs">observations = Vector{Float64}(undef, 1)
observations .= process_member_data(SimDir(simulation.output_dir))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 126.61227416992188</code></pre><p>Now we are ready to run our calibration, putting it all together using the <code>calibrate</code> function. The <code>WorkerBackend</code> will automatically use all workers available to the main Julia process. Other backends are available for forward models that can&#39;t use workers or need to be parallelized internally. The simplest backend is the <code>JuliaBackend</code>, which runs all ensemble members sequentially and does not require <code>Distributed.jl</code>. For more information, see the <a href="https://clima.github.io/ClimaCalibrate.jl/dev/backends/"><code>Backends</code></a> page.</p><pre><code class="language-julia hljs">eki = CAL.calibrate(
    CAL.WorkerBackend,
    ensemble_size,
    n_iterations,
    observations,
    noise,
    prior,
    output_dir,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleKalmanProcesses.EnsembleKalmanProcess{Float64, Int64, EnsembleKalmanProcesses.Inversion, EnsembleKalmanProcesses.DataMisfitController{Float64, Matrix{Float64}, String}, EnsembleKalmanProcesses.NesterovAccelerator{Float64}, Vector{EnsembleKalmanProcesses.UpdateGroup}}(EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}[EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.152987101423427 23.113430885124696 … 23.79546679184483 23.458185685100936]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.314276288970888 23.34756442634027 … 24.02594751719141 23.691073937196325]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.80634716729389 24.210426150945732 … 24.86745003297321 24.546618915358117]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.707191358906265 25.15163147173795 … 25.68930681823323 25.44578360627099]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.749013819647477 25.92431978668205 … 25.9203405756842 25.995001303468765]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.734667094058764 25.849018802695017 … 25.732335881552977 25.725190830816384]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.73095626101206 25.77216974834608 … 25.730521318344774 25.740533252454924]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([25.73033989646776 25.737553595332773 … 25.7305483170922 25.738213661452864])], EnsembleKalmanProcesses.ObservationSeries{Vector{EnsembleKalmanProcesses.Observation{Vector{Vector{Float64}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{String}, Vector{UnitRange{Int64}}}}, EnsembleKalmanProcesses.FixedMinibatcher{Vector{Vector{Int64}}, String, Random.TaskLocalRNG}, Vector{String}, Vector{Vector{Vector{Int64}}}}(EnsembleKalmanProcesses.Observation{Vector{Vector{Float64}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{String}, Vector{UnitRange{Int64}}}[EnsembleKalmanProcesses.Observation{Vector{Vector{Float64}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{String}, Vector{UnitRange{Int64}}}([[126.61227416992188]], LinearAlgebra.Diagonal{Float64, Vector{Float64}}[[0.1;;]], LinearAlgebra.Diagonal{Float64, Vector{Float64}}[[10.0;;]], [&quot;observation&quot;], UnitRange{Int64}[1:1])], EnsembleKalmanProcesses.FixedMinibatcher{Vector{Vector{Int64}}, String, Random.TaskLocalRNG}([[1]], &quot;order&quot;, Random.TaskLocalRNG()), [&quot;series_1&quot;], Dict(&quot;minibatch&quot; =&gt; 1, &quot;epoch&quot; =&gt; 8), [[[1]], [[1]], [[1]], [[1]], [[1]], [[1]], [[1]], [[1]]]), 30, EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}[EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([39.856815338134766 0.6747385859489441 … 2.639543056488037 1.3445641994476318]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([55.0226936340332 1.0776984691619873 … 4.185171127319336 2.1421849727630615]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([147.12078857421875 6.052587985992432 … 22.519323348999023 11.855783462524414]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([120.6773452758789 39.74892044067383 … 116.4403305053711 71.56739044189453]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([131.19647216796875 186.22244262695312 … 184.74783325195312 214.45733642578125]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([127.48892211914062 160.21478271484375 … 126.89599609375 125.09740447998047]), EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([126.54666137695312 137.4098358154297 … 126.43677520751953 128.9918670654297])], [46702.59731584501, 102998.40361570886, 49425.46040482298, 3167.023088149553, 2095.3445153412367, 764.4108011076192, 30.80600957709326], EnsembleKalmanProcesses.DataMisfitController{Float64, Matrix{Float64}, String}([7], [[3.1622776601683795;;]], 1.0, &quot;stop&quot;), EnsembleKalmanProcesses.NesterovAccelerator{Float64}([25.731119674677338 25.74527759752129 … 25.730958411896214 25.734606694853447], 0.20434762801820305), [2.9687995971797056e-6, 2.8039968514080652e-5, 2.34696649418312e-5, 3.1654557861450826e-5, 4.203335806716946e-5, 7.46562806609526e-5, 0.0005679753567004268], EnsembleKalmanProcesses.UpdateGroup[EnsembleKalmanProcesses.UpdateGroup([1], [1], Dict(&quot;[1,...,1]&quot; =&gt; &quot;[1,...,1]&quot;))], EnsembleKalmanProcesses.Inversion(), Random.MersenneTwister(1234, (0, 1002, 0, 245)), EnsembleKalmanProcesses.FailureHandler{EnsembleKalmanProcesses.Inversion, EnsembleKalmanProcesses.SampleSuccGauss}(EnsembleKalmanProcesses.var&quot;#failsafe_update#137&quot;()), EnsembleKalmanProcesses.Localizers.Localizer{EnsembleKalmanProcesses.Localizers.SECNice, Float64}(EnsembleKalmanProcesses.Localizers.var&quot;#13#14&quot;{EnsembleKalmanProcesses.Localizers.SECNice{Float64}}(EnsembleKalmanProcesses.Localizers.SECNice{Float64}(1000, 1.0, 1.0))), false)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Getting Started</a><a class="docs-footer-nextpage" href="../backends/">Backends »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Friday 14 February 2025 18:01">Friday 14 February 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
